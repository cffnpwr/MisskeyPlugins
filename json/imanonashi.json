{
  "type": "plugin",
  "data": "/// @ 0.16.0\n### {\n  name: \"いまのなし(aiscript0.12.4以降対応版)\"\n  version: \"2.0.0\"\n  author: \"@elysion (Original: taiy)\"\n  description: \"消せ消せ消せ消せ消せ\"\n  permissions: [\"write:notes\"]\n  config: {\n    exactWords: {\n      type: \"string\"\n      label: \"単語(完全一致)\"\n      description: \"(既定値: いまのなし) カンマ区切りで複数指定します。nyaizeは以下の言語に対応しています。 ja-JP, en-US\"\n      default: \"いまのなし\"\n    }\n    partialWords: {\n      type: \"string\"\n      label: \"単語(部分一致)\"\n      description: \"(既定値なし) 【単語(完全一致)】 の説明を参照します。\"\n      default: \"\"\n    }\n    exactAlert: {\n      type: \"boolean\"\n      label: \"削除を確認する(完全一致)\"\n      description: \"(既定値: 有効)\"\n      default: true\n    }\n    partialAlert: {\n      type: \"boolean\"\n      label: \"削除を確認する(部分一致)\"\n      description: \"(既定値: 有効)\"\n      default: true\n    }\n  }\n}\n\nlet limitObj = {\n  userId: USER_ID\n  limit: 1\n}\n\n:: Arr {\n  @at(arr index) {\n    return if ((index < 0) || (arr.len <= index)) null\n    else arr[index]\n  }\n  @lastAt(arr) {\n    return Arr:at(arr (arr.len-1))\n  }\n}\n\n:: Str {\n  @replaceFn(text old func) {\n    let textU = text.upper()\n    let oldU = old.upper()\n    let oldLen = old.len\n    let textUArr = textU.split(oldU)\n    let obj = textUArr.reduce(@(prev cur i) {\n      if (i != 1) {\n        let begin = prev.len\n        let end = (begin + oldLen)\n        prev.len = end\n        prev.arr.push({\n          isMatched: true\n          string: text.slice(begin end)\n        })\n      }\n      let begin = prev.len\n      let end = (begin + cur.len)\n      prev.len = end\n      prev.arr.push({\n        isMatched: false\n        string: text.slice(begin end)\n      })\n      return prev\n    } {len: 1, arr: []})\n    return obj.arr.map(@(o) {\n      return if (o.string == \"\") \"\"\n      elif o.isMatched func(o.string)\n      else o.string\n    }).join(\"\")\n  }\n  @nyaize(text) {\n    text = text.replace(\"な\" \"にゃ\").replace(\"ナ\" \"ニャ\").replace(\"ﾅ\" \"ﾆｬ\")\n    text = Str:replaceFn(text \"na\" @(old) {\n      let x = if (old.slice(2 3) == \"A\") \"YA\" else \"ya\"\n      return `{old.slice(1 2)}{x}`\n    })\n    text = Str:replaceFn(text \"morning\" @(old) {\n      let x = if (old.slice(5 8) == \"ING\") \"YAN\" else \"yan\"\n      return `{old.slice(1 5)}{x}`\n    })\n    text = Str:replaceFn(text \"everyone\" @(old) {\n      let x = if (old.slice(6 9) == \"ONE\") \"NYAN\" else \"nyan\"\n      return `{old.slice(1 6)}{x}`\n    })\n    return text\n  }\n  @quote(text) {\n    return `> {text.split(Str:lf).join(`{Str:lf}> `)}`\n  }\n}\n\n@remove_null_property(object) {\n  if Core:type(object) != 'obj' {\n    return object\n  }\n  let new_obj = {}\n  each let kv Obj:kvs(object) {\n    let v = remove_null_property(kv[1])\n    if Core:type(v) != 'null' {\n      Obj:set(new_obj kv[0] v)\n    }\n  }\n  return new_obj\n}\n\nlet c = {}\n\nc.exactAlert = Plugin:config.exactAlert\nc.exactWords = Plugin:config.exactWords\nif (c.exactWords == \"\") {\n  c.exactWords = \"いまのなし\"\n}\nlet exactMatches = c.exactWords.split(\",\").map(@(m) { m.trim() }).filter(@(m) {(m != \"\")})\nexactMatches.map(@(m) {\n  exactMatches.unshift(Str:nyaize(m))\n})\n\nc.partialAlert = Plugin:config.partialAlert\nc.partialWords = Plugin:config.partialWords\nif (c.partialWords == \"\") {\n  c.partialWords = \"\"\n}\nlet partialMatches = c.partialWords.split(\",\").map(@(m) { m.trim() }).filter(@(m) {(m != \"\")})\npartialMatches.map(@(m) {\n  partialMatches.unshift(Str:nyaize(m))\n})\n\nlet queue = []\nAsync:interval(1000 @() {\n  let obj = queue.shift()\n  if (obj == null) return null\n  let alert = match obj.type {\n    1 => c.exactAlert\n    2 => c.partialAlert\n    3 => (c.exactAlert || c.partialAlert)\n  }\n  let note = obj.note\n  let flag = if alert Mk:confirm(\"\" `このノートを削除しますか？{Str:lf}{Str:quote(note.text)}` \"warning\") else true\n  if flag {\n    Mk:api(\"notes/delete\" {\n      noteId: note.id\n    })\n  }\n})\n\n@judge(text) {\n  var exact = false\n  var partial = false\n  exactMatches.find(@(m) {\n    exact = (text == m)\n    return exact\n  })\n  partialMatches.find(@(m) {\n    partial = text.incl(m)\n    return partial\n  })\n  return {exact: exact, partial: partial}\n}\n\nPlugin:register_note_post_interruptor(@(note) {\n  let text = Obj:get(note \"text\")\n  let judge = judge(text)\n  let type = if (judge.exact && judge.partial) 3\n  elif judge.exact 1\n  elif judge.partial 2\n  else 0\n  if (type != 0) {\n    queue.push({\n      type: type,\n      note: Arr:lastAt(Mk:api(\"users/notes\" limitObj))\n    })\n  }\n  return remove_null_property(note)\n})"
}